/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.selenium.ByProperty;
import org.xtext.example.mydsl.selenium.Check;
import org.xtext.example.mydsl.selenium.Element;
import org.xtext.example.mydsl.selenium.FillText;
import org.xtext.example.mydsl.selenium.Global;
import org.xtext.example.mydsl.selenium.Go;
import org.xtext.example.mydsl.selenium.Program;
import org.xtext.example.mydsl.selenium.SelectCombo;
import org.xtext.example.mydsl.selenium.SeleniumPackage;
import org.xtext.example.mydsl.selenium.Variable;
import org.xtext.example.mydsl.selenium.Verify;
import org.xtext.example.mydsl.services.SeleniumGrammarAccess;

@SuppressWarnings("all")
public class SeleniumSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SeleniumGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SeleniumPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SeleniumPackage.BY_PROPERTY:
				sequence_ByProperty(context, (ByProperty) semanticObject); 
				return; 
			case SeleniumPackage.CHECK:
				sequence_Check(context, (Check) semanticObject); 
				return; 
			case SeleniumPackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case SeleniumPackage.FILL_TEXT:
				sequence_FillText(context, (FillText) semanticObject); 
				return; 
			case SeleniumPackage.GLOBAL:
				sequence_Global(context, (Global) semanticObject); 
				return; 
			case SeleniumPackage.GO:
				sequence_Go(context, (Go) semanticObject); 
				return; 
			case SeleniumPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case SeleniumPackage.SELECT_COMBO:
				sequence_SelectCombo(context, (SelectCombo) semanticObject); 
				return; 
			case SeleniumPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case SeleniumPackage.VERIFY:
				sequence_Verify(context, (Verify) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     By returns ByProperty
	 *     ByProperty returns ByProperty
	 *
	 * Constraint:
	 *     property+=STRING
	 */
	protected void sequence_ByProperty(ISerializationContext context, ByProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Check
	 *     Check returns Check
	 *
	 * Constraint:
	 *     (by=By target=STRING)
	 */
	protected void sequence_Check(ISerializationContext context, Check semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeleniumPackage.Literals.CHECK__BY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleniumPackage.Literals.CHECK__BY));
			if (transientValues.isValueTransient(semanticObject, SeleniumPackage.Literals.CHECK__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleniumPackage.Literals.CHECK__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckAccess().getByByParserRuleCall_1_1_0_0(), semanticObject.getBy());
		feeder.accept(grammarAccess.getCheckAccess().getTargetSTRINGTerminalRuleCall_1_1_1_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Element
	 *     Click returns Element
	 *     Element returns Element
	 *
	 * Constraint:
	 *     (type=Type? number=INT? selector=By (target=STRING | var=[Variable|ID]))
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns FillText
	 *     FillText returns FillText
	 *
	 * Constraint:
	 *     ((text=STRING | var=[Variable|ID]) prop=ByProperty target=STRING)
	 */
	protected void sequence_FillText(ISerializationContext context, FillText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Global returns Global
	 *
	 * Constraint:
	 *     programs+=Program+
	 */
	protected void sequence_Global(ISerializationContext context, Global semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Go
	 *     Go returns Go
	 *
	 * Constraint:
	 *     url=STRING
	 */
	protected void sequence_Go(ISerializationContext context, Go semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeleniumPackage.Literals.GO__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleniumPackage.Literals.GO__URL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGoAccess().getUrlSTRINGTerminalRuleCall_1_0(), semanticObject.getUrl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (name=ID (ret='true' | ret='false') ins+=Instruction*)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns SelectCombo
	 *     SelectCombo returns SelectCombo
	 *
	 * Constraint:
	 *     (by=By target=STRING)
	 */
	protected void sequence_SelectCombo(ISerializationContext context, SelectCombo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SeleniumPackage.Literals.SELECT_COMBO__BY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleniumPackage.Literals.SELECT_COMBO__BY));
			if (transientValues.isValueTransient(semanticObject, SeleniumPackage.Literals.SELECT_COMBO__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SeleniumPackage.Literals.SELECT_COMBO__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectComboAccess().getByByParserRuleCall_1_0(), semanticObject.getBy());
		feeder.accept(grammarAccess.getSelectComboAccess().getTargetSTRINGTerminalRuleCall_2_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Variable
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID attr=STRING? elem=Element)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Verify
	 *     Verify returns Verify
	 *
	 * Constraint:
	 *     (elem=Element? (text=STRING | var=[Variable|ID] | Element=Element))
	 */
	protected void sequence_Verify(ISerializationContext context, Verify semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
